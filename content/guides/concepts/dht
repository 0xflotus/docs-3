---
title: "Distributed Hash Table (DHT)"
menu:
    guides:
        parent: concepts
---

## DHT

Distributed Hash Tables (DHT) are a distributed key-value store where key are cryptographic hashes. 

DHTs are usually too big to be stored entirely by each peer, so they are distributed: each peer is responsible for a fraction of the DHT (redundantly). 
These subsets are called 'buckets', and map to some prefix of the hash. For exemple, a peer can be responsible for lookups for hash beginning by Qme8T33g...
More precisely, a peer maintains the DHT for hashes which share their prefix with its own PeerID (which is also a hash).

For example, the peer with PeerID "ABCDEF12345" can be responsible to maintain mapping for all hashes starting with the prefix "ABCD". 
Some hashes that would fall into this bucket would be ABCD38E56, ABCD09CBA or ABCD17ABB. 

The size of the buckets are directly related to the size of the prefix: the longer the prefix, the less hashes each nodes has to manage, the more nodes is needed.

In most DHTs' implementations, including Kademlia which is used by IPFS, the size of the buckets, or the size of the prefix, is dynamic. 
Buckets size growth and prefix size shortens when many nodes leaves the DHT, and vice versa. (or does it depends of the number of records and not the number of nodes? Is it at a bucket level or DHT level?)

Peers also keep connection to other peers so that they can forward requests if the requested hash is not in their own bucket.
If hashes are of lentgh n, they will keep n lists of peers: 
- the first list contains peers which ID have a different 1st bit.
- the second list contains peer which have their first bits indentical to its own, but a different second bit
- ...
- the m-th list contains peer which have their first m-1 bits identical, but a differnt m-th bit
- ...

The higher m, the harder it is to find peers which have the same ID up to m bits. The lists of "closest" peers typically remains empty.
"Close" here is defined as the XOR distance, so the longer the prefix they share, the closer they are.

List also have a maximum of entries k, otherwise the first lists would contain half the network, then a fourth, etc.





DHT provides additionnal advantages compared to a classic Key-Value store:
- *scalability* as each node only needs to manage a fraction of the Key-Value pairs.
- *fault tolerance* via redunduncy, so that lookup are possible even if nodes unexpectedly leave or join the DHT.
- *load balancing* as requests are made to different nodes and no unique nodes process all the requests

## The DHT of IPFS

# Use of DHT in IPFS

In IPFS, keys are not hashes but multihashes: a generalisation of the cryptographic hashes containing information about which hashing function was used, and the length of the hash.

We use a DHT to lookup two types of objects (both represented by a multihash):
- Content IDs of the data added to IPFS. A lookup of this value will give the peerIDs of the peers having this content.
- PeerIDs of IPFS (libp2p?) nodes. A lookup will give all the multiaddresses to reach the peer(s) actually having the content.
Consequently, IPFS's DHT is use for content routing (1st lookup) and for peer routing (2nd lookup). 


# How it works
When a peer A sends a lookup request to a peer B, B will check if the requested hash falls into its bucket. If it does, it serves the request. If it doesn't, it will forward it to the peer it knows having the 'closer' peerID to the requested hash. 
For exemple, if peer A request the hash *QmAAAA*... and peer B's ID is *QmBBBB*..., it might forward the request to its peer C which Id is *QmAA*CC. 
This peer will also either answer the request or forward it.




Hashes are functions that take some arbitrary input and return a fixed-length value. The particular value depends on the given hash algorithm in use, such as [SHA-1](https://en.wikipedia.org/wiki/SHA-1) (used by Git), [SHA-256](https://en.wikipedia.org/wiki/SHA-2), or [BLAKE2](https://en.wikipedia.org/wiki/BLAKE_(hash_function)#BLAKE2), but a given hash algorithm always returns the same value for a given input. Have a look at the [full list of hash functions](https://en.wikipedia.org/wiki/List_of_hash_functions) for more.

As an example, the input:

```
Hello world
```

would be represented by **SHA-1** as:

```
0x7B502C3A1F48C8609AE212CDFB639DEE39673F5E
```

However, the exact same input generates the following output using **SHA-256**:

```
0x64EC88CA00B268E5BA1A35678A1B5316D212F4F366B2477232534A8AECA37F3C
```

Notice that the second hash is longer than the first one. This is because SHA-1 creates a 160 bit hash, while SHA-256 creates a 256 bit hash. Also, the prepended `0x` is just an indicator that tells us that the following hash is represented as a base 16 (or hexadecimal) number.

Hashes can be represented in different bases (`base2`, `base16`, `base32`, etc.). In fact, IPFS makes use of that as part of its [Content Identifiers]({{< relref "cid.md" >}}) and supports mulitiple base representations at the same time, using the [Multibase](https://github.com/multiformats/multibase) protocol.

For example, the SHA-256 hash of "Hello World" from above can be represented as base 32 as:

```
mtwirsqawjuoloq2gvtyug2tc3jbf5htm2zeo4rsknfiv3fdp46a
```

## Characteristics of cryptographic hashes

Cryptographic hashes come with a couple of very important characteristics:

- **deterministic** - the same input message always returns exactly the same output hash
- **uncorrelated** - a small change in the message should generate a completely different hash
- **unique** - it's infeasible to generate the same hash from two different messages
- **one-way** - it's infeasible to guess or calculate the input message from its hash

It turns out these features also mean we can use a cryptographic hash to identify any piece of data: the hash is unique to the data we calculated it from and it’s not too long (a hash is a fixed length, so the SHA-256 hash of a 1 Gigabyte video file is still only 32 bytes), so sending it around the network doesn't take up a lot of resources.

That's critical for a distributed system like IPFS, where we want to be able to store and retrieve data from many places. A computer running IPFS can ask all the peers it's connected to  whether they have a file with a particular hash and, if one of them does, they send back the whole file. Without a short, unique identifier like a cryptographic hash, that wouldn't be possible. This technique is called “content addressing” — because the content itself is used to form an address, rather than information about the computer and disk location it's stored at.

